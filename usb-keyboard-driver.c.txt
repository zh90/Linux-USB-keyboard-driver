#include <Linux/kernel.h>
#include <Linux/slab.h>
#include <Linux/module.h>
#include <input.h>
#include <init.h>
#include <Linux/usb.h>

static unsigned char usb_kbd_keycode[256]=
{
	0, 0, 0, 0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38,
    	50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44, 2, 3,
    	4, 5, 6, 7, 8, 9, 10, 11, 28, 1, 14, 15, 57, 12, 13, 26,
    	27, 43, 43, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64, 
    	65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106,
    	105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71, 
    	72, 73, 82, 83, 86,127,116,117,183,184,185,186,187,188,189,190, 
    	191,192,193,194,134,138,130,132,128,129,131,137,133,135,136,113, 
    	115,114, 0, 0, 0,121, 0, 89, 93,124, 92, 94, 95, 0, 0, 0, 
    	122,123, 90, 91, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    	29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113, 
    	150,158,159,128,136,177,178,176,142,152,173,140
}

struct usb_kbd { 
    struct input_dev *dev; 
    struct usb_device *usbdev;
    unsigned char old[8]; 
    struct urb *irq;
    unsigned char newleds;
    char name[128];
    char phys[64];
    unsigned char *new;
    struct usb_ctrlrequest *cr; 
    unsigned char *leds; 
    dma_addr_t cr_dma; 
    dma_addr_t new_dma;  
    dma_addr_t leds_dma; 
 };

static struct usb_driver usb_kbd_driver = { 
    .name =   "usbkbd";
    .probe = usb_kbd_probe;
    .disconnect = usb_kbd_disconnect; 
    .id_table =   usb_kbd_id_table; 
};

static int __init usb_kbd_init(void)

 
{
    int result = usb_register(&usb_kbd_driver);/*注册USB键盘驱动*/ 
    if (result == 0) /*注册失败*/
    info(DRIVER_VERSION ":" DRIVER_DESC);
    return result;
 }

static void __exit usb_kbd_exit(void)
{ 
    printk("SUNWILL-USBKBD:usb_kbd_exit begin...\n"); 
    usb_deregister(&usb_kbd_driver);
 } 

static struct usb_device_id usb_kbd_id_table [] = { 

　　{ USB_INTERFACE_INFO(3, 1, 1) },
    { }

　　};
MODULE_DEVICE_TABLE (usb, usb_kbd_id_table);

module_init(usb_kbd_init);

module_exit(usb_kbd_exit);

　　static void usb_kbd_irq(struct urb *urb, struct pt_regs *regs) 

　　{ 

　　struct usb_kbd *kbd = urb->context; 

　　int i; 

　　switch (urb->status) { 

　　case 0: 

　　break; 

　　case -ECONNRESET:

　　case -ENOENT: 

　　case -ESHUTDOWN: 

　　return; 

　　

　　default: 

　　goto resubmit; 

　　} 
 

　　

　　for (i = 0; i < 8; i++) 

　　{ 

　　input_report_key(kbd->dev, usb_kbd_keycode[i + 224], (kbd->new[0] >> i) & 1); 

　　} 

　

　　for (i = 2; i < 8; i++) { 



　　if (kbd->old > 3 && memscan(kbd->new + 2, kbd->old, 6) == kbd->new + 8) { 

　　if (usb_kbd_keycode[kbd->old]) 

　　{ 

　　input_report_key(kbd->dev, usb_kbd_keycode[kbd->old], 0); 

　　} 

　　else 

　　info("Unknown key (scancode %#x) released.", kbd->old); 

　　} 



　　if (kbd->new > 3 && memscan(kbd->old + 2, kbd->new, 6) == kbd->old + 8) {

　　if (usb_kbd_keycode[kbd->new]) 

　　{ 

　　input_report_key(kbd->dev, usb_kbd_keycode[kbd->new], 1); 

　　} 

　　else 

　　info("Unknown key (scancode %#x) pressed.", kbd->new); 

　　} 

　　} 



　　input_sync(kbd->dev); 

　　memcpy(kbd->old, kbd->new, 8);

　　resubmit: 

　　i = usb_submit_urb (urb, GFP_ATOMIC);

　　if (i) 

　　err ("can't resubmit intr, %s-%s/input0, status %d", 

　　kbd->usbdev->bus->bus_name, 

　　kbd->usbdev->devpath, i); 

　　}


    static int usb_kbd_event(struct input_dev *dev, unsigned int type, 

　　unsigned int code, int value) 

　　{ 

　　struct usb_kbd *kbd = dev->private; 

　　if (type != EV_LED) /*不支持LED事件 */ 

　　return -1; 

　　/*获取指示灯的目标状态*/ 

　　kbd->newleds = (!!test_bit(LED_KANA, dev->led) << 3) | (!!test_bit(LED_COMPOSE, dev->led) << 3) | 

　　(!!test_bit(LED_SCROLLL, dev->led) << 2) | (!!test_bit(LED_CAPSL, dev->led) << 1) | 

　　(!!test_bit(LED_NUML, dev->led)); 

　　if (kbd->led->status == -EINPROGRESS) 

　　return 0; 

　　/* 

　　指示灯状态已经是目标状态则不需要再做任何操作*/ 

　　if (*(kbd->leds) == kbd->newleds) 

　　return 0; 

　　*(kbd->leds) = kbd->newleds; 

　　kbd->led->dev = kbd->usbdev; 

　　/*发送usb请求块*/ 

　　if (usb_submit_urb(kbd->led, GFP_ATOMIC)) 

　　err("usb_submit_urb(leds) failed"); 

　　return 0; 

　　}

/*接在event之后操作，该功能其实usb_kbd_event中已经有了，该函数的作用可能是防止event的操作失败，一般注释掉该函数中的所有行都可以正常工作*/ 

　　static void usb_kbd_led(struct urb *urb, struct pt_regs *regs) 

　　{ 

　　struct usb_kbd *kbd = urb->context; 

　　if (urb->status) 

　　warn("led urb status %d received", urb->status); 

　　if (*(kbd->leds) == kbd->newleds)/* 

　　指示灯状态已经是目标状态则不需要再做任何操作*/ 

　　return; 

　　*(kbd->leds) = kbd->newleds; 

　　kbd->led->dev = kbd->usbdev; 

　　if (usb_submit_urb(kbd->led, GFP_ATOMIC)) 

　　err("usb_submit_urb(leds) failed"); 

　　} 

/*打开键盘设备时，开始提交在 probe 函数中构建的 urb，进入 urb 周期。 */ 

　　static int usb_kbd_open(struct input_dev *dev) 

　　{ 

　　struct usb_kbd *kbd = dev->private; 

　　kbd->irq->dev = kbd->usbdev; 

　　if (usb_submit_urb(kbd->irq, GFP_KERNEL)) 

　　return -EIO; 

　　return 0; 

　　}

　　/*关闭键盘设备时，结束 urb 生命周期。 */ 

　　static void usb_kbd_close(struct input_dev *dev) 

　　{ 

　　struct usb_kbd *kbd = dev->private; 

　　usb_kill_urb(kbd->irq); /*取消kbd->irq这个usb请求块*/ 

　　} 

